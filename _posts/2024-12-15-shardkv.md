---
date: 2024-12-15
title: "MIT-6.5840-ShardKV"
category: 学习经验
tags: [MIT-6.5840,分布式系统]
excerpt: "MIT-6.5840 Lab 5 实现回顾"
---

该课程系列的最后一个lab，个人认为难度非常高。事后来看似乎也就那么一回事，但找到正解的过程真的很困难，耗费了大量的时间。临近期末，有很多事要处理，没有将百分百的精力花在这上面，前后大概用了十天的时间完成了该lab，这里也抽空趁记忆没有模糊之前赶紧草草记录下实现的回顾。

之后应该会写一个对于整个课程的回顾，但估计得等到明年了，接下来不得不把时间浪费在应付学校课程上了。

最后的实现方案成功通过了包括challenge在内的所有测试10000次，虽然在我看来这个实现方案有一些说不清的不和谐感，但既然测试通过了那我也不管那么多了。

![](/assets/.....)

# MIT-6.5840-lab5-ShardKV

正如前面所说的实现起来其实也就那么一回事，因为说到底都是基于Raft的一些应用构建罢了。

等所有的lab完成到这一步，应该要对自己的Raft有百分百的自信。幸运的是至少我的Raft在经过lab4的锤炼之后变得足够健壮，在这个lab中我完全没有考虑过Raft的错误，将注意力集中到应用层的结构上，这节省了我的大量精力。所以一定要保证Raft的正确性，前面的lab的测试至少要测试10000次才可以说是正确。

## Part A: The Controller and Static Sharding

实现一个配置控制器，本质就是一个KV server。

跟Hint说的一样，这部分基本就是照搬lab4的实现，唯一值得说的就是rebalance算法的设计

### Rebalance

当一台机器加入，离开或者移动时，要对现有的shard进行重新分配。为此要设计一个分配算法来保证**move as few shards as possible to achieve that goal**

为了想这个分配算法说实话花了不少时间，不过最后的做法其实相当蠢。

虽然直接给出代码讲解会更简单，但是出于学术诚信（实验的仓库应该之后会设为私有），这里尽量以讲解思路为主。

在完成一次更新后，重新平衡之前，两个config之间的唯一区别在于`Config.Groups`不同，然后进入rebalance：

1. 首先找出在新的config中不属于任何gid的shard，我们称为`orphanShards`

    这步通过检查在`oldConfig.Shards`记录的gid是否在`newConfid.Groups`中存在来实现。

2. 同时记录在新旧config中不变的shard

    显然除去`orphanShards`以外就都是不变的shards。将这个结果保存在一个由以下结构体组成的切片`GSs`下
    ```go
    type GS struct {    // Gid and Shards
		Gid    int
		Shards []int
	}
    GSs := make([]GS, 0)
    ```
    每一项记录一个Gid对应的Shards，之后我们会频繁修改该集合来实现平衡

3. 接着排序`GSs`

    正如Hints所说，go的哈希表和C++的unordered_map一样是一个无序的实现，所以在不同的机器上相同记录的map在遍历时的顺序可能不同，这导致`GSs`在不同的机器上的记录可能不一致，这显然会导致最后的rebalance结果不同。

    所以我们对`GSs`先根据gid进行排序，然后再对内部的`GS.Shards`也进行一个排序，以此保证在进入下一步之前所有机器是一致的。

4. 通过简单的遍历找出哪两个Gid拥有的Shards最少和最多

    因为`NShards`只有10，所以这里直接用遍历来获取了，只要前面保证了`GSs`的有序就可以保证这里获取的最少和最多在所有机器上都是相同的，

5. 如果`orphanShards`还有剩余即不为空，则将其的最后一个取出加入到拥有最少的Shards的Gid的Shards中，然后重复第4步。

6. 如果`orphanShards`没有剩余，则检查最多的Shards和最少的Shards相差是否大于1，如果大于1则将最多Shards中的一个移动到最少的Shards中，然后重复第4步。

7. 如果相差小于等于1说明已经重新平衡完毕，此时将`GSs`中记录的最终结果应用到`NewConfig`上后结束平衡。

非常简单的算法，但我想我应该思考了一两个小时才想通。

## Part B: Shard Movement

非常棘手的一部分，虽然框架还是延续lab4的做法，但区别在于这次我们要让各个服务器之间进行直接的通信来实现移动。

为此我们不得不引入了一些新的机制，可以先看下两者在数据结构上的不同来初步窥探下为了实现Part B我们做出了哪些修改：

![](/assets/images/2024-12-15-shardkv/Figure2.png)

